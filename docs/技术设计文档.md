# 文流 (WenLiu) - 技术设计文档

## 1. 技术选型说明

### 1.1 前端技术选型

#### Next.js 14+ 选择理由
- **全栈能力**: 同时支持前端和API开发，减少技术栈复杂度
- **零配置**: 内置TypeScript、Tailwind CSS支持
- **性能优化**: 自动代码分割、图片优化、SSR支持
- **部署简单**: Vercel一键部署，零成本启动

#### TypeScript 选择理由
- **类型安全**: 编译时错误检查，减少运行时错误
- **开发效率**: 智能代码补全和重构支持
- **代码质量**: 更好的代码可读性和维护性
- **团队协作**: 统一的代码规范和接口定义

#### Tailwind CSS 选择理由
- **开发效率**: 原子化CSS类，快速构建UI
- **一致性**: 统一的设计系统和样式规范
- **性能**: 按需生成CSS，减少包体积
- **响应式**: 内置响应式设计支持

### 1.2 后端技术选型

#### Drizzle ORM 选择理由
- **类型安全**: 完全的TypeScript支持
- **性能**: 轻量级，接近原生SQL性能
- **开发体验**: 直观的API和强大的查询构建器
- **迁移管理**: 自动化的数据库迁移

#### SQLite/Turso 选择理由
- **零成本**: 开发环境SQLite，生产环境Turso免费版
- **性能**: 优秀的读写性能
- **简单**: 无需复杂的数据库配置
- **扩展性**: 后期可平滑升级到分布式数据库

## 2. 核心模块技术实现

### 2.1 内容编辑器实现

#### Markdown编辑器集成
```typescript
// 编辑器组件
import MDEditor from '@uiw/react-md-editor';
import { useState, useEffect } from 'react';

interface ArticleEditor {
  value: string;
  onChange: (value: string) => void;
  onSave: () => void;
}

const ArticleEditor: React.FC<ArticleEditor> = ({ value, onChange, onSave }) => {
  const [content, setContent] = useState(value);
  
  // 自动保存
  useEffect(() => {
    const timer = setTimeout(() => {
      if (content !== value) {
        onChange(content);
        onSave();
      }
    }, 2000);
    
    return () => clearTimeout(timer);
  }, [content]);
  
  return (
    <MDEditor
      value={content}
      onChange={(val) => setContent(val || '')}
      preview="edit"
      hideToolbar={false}
      visibleDragBar={false}
    />
  );
};
```

#### 文档导入功能
```typescript
// 文档导入服务
class DocumentImportService {
  async importMarkdown(file: File): Promise<string> {
    const text = await file.text();
    return this.processMarkdown(text);
  }
  
  async importWord(file: File): Promise<string> {
    // 使用mammoth.js或类似库转换Word文档
    const arrayBuffer = await file.arrayBuffer();
    const result = await mammoth.convertToMarkdown({ arrayBuffer });
    return this.processMarkdown(result.value);
  }
  
  private processMarkdown(content: string): string {
    // 处理图片链接
    content = this.processImages(content);
    // 清理格式
    content = this.cleanupFormat(content);
    return content;
  }
  
  private processImages(content: string): string {
    // 提取图片并上传到图床
    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
    return content.replace(imageRegex, (match, alt, src) => {
      // 异步上传图片并替换链接
      this.uploadImage(src).then(newUrl => {
        return `![${alt}](${newUrl})`;
      });
      return match;
    });
  }
}
```

### 2.2 格式转换引擎

#### 公众号格式转换
```typescript
// 公众号格式转换器
import { marked } from 'marked';

class WechatConverter {
  private styles = {
    default: `
      <style>
        .wechat-content { 
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto; 
          line-height: 1.8; 
          color: #333; 
          max-width: 100%;
        }
        .wechat-content h1 { 
          color: #2c3e50; 
          border-bottom: 2px solid #3498db; 
          padding-bottom: 8px; 
          margin: 24px 0 16px 0;
          font-size: 24px;
        }
        .wechat-content h2 { 
          color: #34495e; 
          border-left: 4px solid #3498db; 
          padding-left: 12px; 
          margin: 20px 0 12px 0;
          font-size: 20px;
        }
        .wechat-content p { 
          margin: 16px 0; 
          text-align: justify;
          font-size: 16px;
        }
        .wechat-content code { 
          background: #f8f9fa; 
          padding: 2px 6px; 
          border-radius: 3px; 
          font-family: 'SF Mono', Monaco, monospace;
          color: #e74c3c;
        }
        .wechat-content pre { 
          background: #f8f9fa; 
          padding: 16px; 
          border-radius: 8px; 
          overflow-x: auto;
          border-left: 4px solid #3498db;
        }
        .wechat-content blockquote { 
          border-left: 4px solid #bdc3c7; 
          padding-left: 16px; 
          margin: 16px 0; 
          color: #7f8c8d;
          font-style: italic;
        }
        .wechat-content img {
          max-width: 100%;
          height: auto;
          display: block;
          margin: 16px auto;
        }
      </style>
    `,
    tech: `/* 技术风格样式 */`,
    minimal: `/* 简约风格样式 */`
  };
  
  convert(markdown: string, style: keyof typeof this.styles = 'default'): string {
    // 配置marked选项
    marked.setOptions({
      breaks: true,
      gfm: true,
    });
    
    const html = marked(markdown);
    
    return `
      ${this.styles[style]}
      <div class="wechat-content">
        ${html}
      </div>
    `;
  }
  
  addRecommendedArticles(html: string, articles: RecommendedArticle[]): string {
    const recommendHtml = this.generateRecommendSection(articles);
    return html + recommendHtml;
  }
  
  private generateRecommendSection(articles: RecommendedArticle[]): string {
    const articleList = articles.map(article => 
      `<li><a href="${article.url}">${article.title}</a></li>`
    ).join('');
    
    return `
      <div class="recommend-section">
        <h3>往期精选</h3>
        <ul>${articleList}</ul>
      </div>
    `;
  }
}
```

#### 多平台适配器
```typescript
// 平台适配器接口
interface PlatformConverter {
  convert(markdown: string, options?: any): string;
  validateContent(content: string): ValidationResult;
  getPreviewUrl(content: string): string;
}

// 知乎适配器
class ZhihuConverter implements PlatformConverter {
  convert(markdown: string): string {
    // 知乎支持基础Markdown，但需要特殊处理
    return marked(markdown, {
      renderer: this.createZhihuRenderer()
    });
  }
  
  private createZhihuRenderer() {
    const renderer = new marked.Renderer();
    
    // 自定义代码块渲染
    renderer.code = (code, language) => {
      return `<pre><code class="language-${language}">${code}</code></pre>`;
    };
    
    // 自定义图片渲染
    renderer.image = (href, title, text) => {
      return `<img src="${href}" alt="${text}" title="${title || ''}" />`;
    };
    
    return renderer;
  }
  
  validateContent(content: string): ValidationResult {
    // 知乎内容验证规则
    const errors: string[] = [];
    
    if (content.length > 50000) {
      errors.push('内容长度超过知乎限制');
    }
    
    return { isValid: errors.length === 0, errors };
  }
}

// 掘金适配器
class JuejinConverter implements PlatformConverter {
  convert(markdown: string): string {
    // 掘金原生支持Markdown
    return markdown;
  }
  
  validateContent(content: string): ValidationResult {
    const errors: string[] = [];
    
    // 检查是否包含技术标签
    if (!this.hasTechContent(content)) {
      errors.push('建议添加技术相关内容');
    }
    
    return { isValid: errors.length === 0, errors };
  }
  
  private hasTechContent(content: string): boolean {
    const techKeywords = ['代码', 'JavaScript', 'Python', 'React', 'Vue', 'Node.js'];
    return techKeywords.some(keyword => content.includes(keyword));
  }
}
```

### 2.3 AI服务集成

#### AI服务抽象层
```typescript
// AI服务接口
interface AIProvider {
  optimizeTitle(content: string): Promise<string[]>;
  generateSummary(content: string): Promise<string>;
  recommendTags(content: string): Promise<string[]>;
  rewriteStyle(content: string, targetStyle: string): Promise<string>;
}

// 通义千问集成
class TongYiAIProvider implements AIProvider {
  private apiKey: string;
  private baseURL: string;
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
    this.baseURL = 'https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation';
  }
  
  async optimizeTitle(content: string): Promise<string[]> {
    const prompt = `
      请为以下文章生成3个吸引人的标题，要求：
      1. 突出核心价值
      2. 激发读者兴趣
      3. 适合社交媒体传播
      
      文章内容：${content.substring(0, 500)}...
      
      请只返回3个标题，每行一个：
    `;
    
    const response = await this.callAPI(prompt);
    return response.split('\n').filter(line => line.trim()).slice(0, 3);
  }
  
  async generateSummary(content: string): Promise<string> {
    const prompt = `
      请为以下文章生成一个简洁的摘要，要求：
      1. 100字以内
      2. 突出核心观点
      3. 吸引读者阅读全文
      
      文章内容：${content}
      
      摘要：
    `;
    
    return await this.callAPI(prompt);
  }
  
  async recommendTags(content: string): Promise<string[]> {
    const prompt = `
      请为以下文章推荐5-8个相关标签，要求：
      1. 准确反映文章主题
      2. 有利于搜索发现
      3. 符合平台标签规范
      
      文章内容：${content.substring(0, 1000)}...
      
      请只返回标签，用逗号分隔：
    `;
    
    const response = await this.callAPI(prompt);
    return response.split(',').map(tag => tag.trim()).filter(tag => tag);
  }
  
  async rewriteStyle(content: string, targetStyle: string): Promise<string> {
    const stylePrompts = {
      xiaohongshu: `
        请将以下内容改写为小红书风格，要求：
        1. 语言轻松活泼
        2. 多使用emoji表情
        3. 分段清晰，易于阅读
        4. 突出实用性和分享价值
      `,
      zhihu: `
        请将以下内容改写为知乎风格，要求：
        1. 逻辑清晰，论证严谨
        2. 语言专业但不失亲和力
        3. 适当添加个人经验和思考
        4. 结构完整，有总结
      `
    };
    
    const prompt = `${stylePrompts[targetStyle]}\n\n原文内容：${content}`;
    return await this.callAPI(prompt);
  }
  
  private async callAPI(prompt: string): Promise<string> {
    try {
      const response = await fetch(this.baseURL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'qwen-turbo',
          input: {
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ]
          },
          parameters: {
            max_tokens: 2000,
            temperature: 0.7
          }
        })
      });
      
      const data = await response.json();
      return data.output.text;
    } catch (error) {
      console.error('AI API调用失败:', error);
      throw new Error('AI服务暂时不可用');
    }
  }
}
```

#### AI使用量控制
```typescript
// AI使用量管理
class AIUsageManager {
  private db: Database;
  
  constructor(db: Database) {
    this.db = db;
  }
  
  async checkUsageLimit(userId: string, featureType: string): Promise<boolean> {
    const currentMonth = new Date().toISOString().substring(0, 7); // YYYY-MM
    
    const usage = await this.db.query.aiUsage.findFirst({
      where: and(
        eq(aiUsage.userId, userId),
        eq(aiUsage.featureType, featureType),
        eq(aiUsage.month, currentMonth)
      )
    });
    
    const limits = this.getFeatureLimits(featureType);
    const currentUsage = usage?.usageCount || 0;
    
    return currentUsage < limits.monthly;
  }
  
  async recordUsage(userId: string, featureType: string): Promise<void> {
    const currentMonth = new Date().toISOString().substring(0, 7);
    
    await this.db.insert(aiUsage).values({
      id: generateId(),
      userId,
      featureType,
      usageCount: 1,
      month: currentMonth,
      createdAt: new Date()
    }).onConflictDoUpdate({
      target: [aiUsage.userId, aiUsage.featureType, aiUsage.month],
      set: {
        usageCount: sql`${aiUsage.usageCount} + 1`
      }
    });
  }
  
  private getFeatureLimits(featureType: string) {
    const limits = {
      'title-optimize': { monthly: 500 },
      'summary-generate': { monthly: 500 },
      'tag-recommend': { monthly: 500 },
      'style-rewrite': { monthly: 100 }
    };
    
    return limits[featureType] || { monthly: 0 };
  }
}
```

### 2.4 Chrome插件实现

#### 内容脚本架构
```javascript
// content/wechat.js - 公众号内容填充
class WechatContentFiller {
  constructor() {
    this.selectors = {
      title: '#title',
      content: '#ueditor_0',
      author: 'input[name="author"]',
      original: 'input[name="original"]',
      reward: 'input[name="reward"]'
    };
  }
  
  async fillContent(data) {
    try {
      // 填充标题
      await this.fillTitle(data.title);
      
      // 填充内容
      await this.fillEditor(data.content);
      
      // 应用预设配置
      if (data.preset) {
        await this.applyPreset(data.preset);
      }
      
      // 处理图片
      if (data.images && data.images.length > 0) {
        await this.processImages(data.images);
      }
      
      this.showSuccessMessage('内容填充成功！');
    } catch (error) {
      this.showErrorMessage('填充失败：' + error.message);
    }
  }
  
  async fillTitle(title) {
    const titleInput = document.querySelector(this.selectors.title);
    if (titleInput) {
      titleInput.value = title;
      titleInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
  }
  
  async fillEditor(content) {
    // 等待编辑器加载完成
    await this.waitForEditor();
    
    const editor = document.querySelector(this.selectors.content);
    if (editor) {
      // 使用UEditor API填充内容
      if (window.UE && window.UE.getEditor) {
        const ueEditor = window.UE.getEditor('ueditor_0');
        if (ueEditor) {
          ueEditor.ready(() => {
            ueEditor.setContent(content);
          });
        }
      } else {
        // 直接设置innerHTML作为备选方案
        editor.innerHTML = content;
      }
    }
  }
  
  async applyPreset(preset) {
    // 设置作者
    if (preset.author) {
      const authorInput = document.querySelector(this.selectors.author);
      if (authorInput) {
        authorInput.value = preset.author;
      }
    }
    
    // 设置原创
    if (preset.original !== undefined) {
      const originalCheckbox = document.querySelector(this.selectors.original);
      if (originalCheckbox) {
        originalCheckbox.checked = preset.original;
      }
    }
    
    // 设置赞赏
    if (preset.reward !== undefined) {
      const rewardCheckbox = document.querySelector(this.selectors.reward);
      if (rewardCheckbox) {
        rewardCheckbox.checked = preset.reward;
      }
    }
  }
  
  async waitForEditor() {
    return new Promise((resolve) => {
      const checkEditor = () => {
        const editor = document.querySelector(this.selectors.content);
        if (editor) {
          resolve();
        } else {
          setTimeout(checkEditor, 100);
        }
      };
      checkEditor();
    });
  }
  
  showSuccessMessage(message) {
    this.showNotification(message, 'success');
  }
  
  showErrorMessage(message) {
    this.showNotification(message, 'error');
  }
  
  showNotification(message, type) {
    const notification = document.createElement('div');
    notification.textContent = message;
    notification.style.cssText = `
      position: fixed; 
      top: 20px; 
      right: 20px; 
      z-index: 9999;
      background: ${type === 'success' ? '#4CAF50' : '#f44336'}; 
      color: white; 
      padding: 12px 20px;
      border-radius: 4px; 
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.remove();
    }, 3000);
  }
}

// 初始化内容填充器
const wechatFiller = new WechatContentFiller();

// 监听来自popup的消息
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'fillContent') {
    wechatFiller.fillContent(message.data)
      .then(() => sendResponse({ success: true }))
      .catch(error => sendResponse({ success: false, error: error.message }));
    return true; // 保持消息通道开放
  }
});
```

#### 弹窗界面实现
```javascript
// popup/popup.js
class PopupManager {
  constructor() {
    this.apiBase = 'http://localhost:3000/api';
    this.init();
  }
  
  async init() {
    await this.loadArticles();
    await this.loadPresets();
    this.bindEvents();
  }
  
  async loadArticles() {
    try {
      const response = await fetch(`${this.apiBase}/articles`, {
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error('获取文章列表失败');
      }
      
      const data = await response.json();
      this.renderArticles(data.articles);
    } catch (error) {
      this.showError('加载文章失败：' + error.message);
    }
  }
  
  async loadPresets() {
    try {
      const response = await fetch(`${this.apiBase}/presets`, {
        credentials: 'include'
      });
      
      if (response.ok) {
        const data = await response.json();
        this.renderPresets(data.presets);
      }
    } catch (error) {
      console.error('加载预设失败：', error);
    }
  }
  
  renderArticles(articles) {
    const container = document.getElementById('articles-list');
    container.innerHTML = '';
    
    articles.forEach(article => {
      const item = document.createElement('div');
      item.className = 'article-item';
      item.innerHTML = `
        <h3>${article.title}</h3>
        <p>${article.wordCount} 字 · ${this.formatDate(article.updatedAt)}</p>
        <button class="publish-btn" data-id="${article.id}">发布</button>
      `;
      container.appendChild(item);
    });
  }
  
  renderPresets(presets) {
    const select = document.getElementById('preset-select');
    select.innerHTML = '<option value="">选择预设</option>';
    
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      if (preset.isDefault) {
        option.selected = true;
      }
      select.appendChild(option);
    });
  }
  
  bindEvents() {
    // 发布按钮事件
    document.addEventListener('click', async (e) => {
      if (e.target.classList.contains('publish-btn')) {
        const articleId = e.target.dataset.id;
        const presetId = document.getElementById('preset-select').value;
        await this.publishArticle(articleId, presetId);
      }
    });
  }
  
  async publishArticle(articleId, presetId) {
    try {
      // 获取文章内容
      const articleResponse = await fetch(`${this.apiBase}/articles/${articleId}`, {
        credentials: 'include'
      });
      const article = await articleResponse.json();
      
      // 获取预设配置
      let preset = null;
      if (presetId) {
        const presetResponse = await fetch(`${this.apiBase}/presets/${presetId}`, {
          credentials: 'include'
        });
        preset = await presetResponse.json();
      }
      
      // 转换为公众号格式
      const convertResponse = await fetch(`${this.apiBase}/convert/wechat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        credentials: 'include',
        body: JSON.stringify({
          content: article.content,
          style: preset?.style || 'default'
        })
      });
      
      const convertData = await convertResponse.json();
      
      // 发送到content script
      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
      
      chrome.tabs.sendMessage(tab.id, {
        action: 'fillContent',
        data: {
          title: article.title,
          content: convertData.html,
          preset: preset?.config,
          images: article.images
        }
      }, (response) => {
        if (response && response.success) {
          this.showSuccess('发布成功！');
        } else {
          this.showError('发布失败：' + (response?.error || '未知错误'));
        }
      });
      
    } catch (error) {
      this.showError('发布失败：' + error.message);
    }
  }
  
  formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('zh-CN');
  }
  
  showSuccess(message) {
    this.showMessage(message, 'success');
  }
  
  showError(message) {
    this.showMessage(message, 'error');
  }
  
  showMessage(message, type) {
    const messageEl = document.getElementById('message');
    messageEl.textContent = message;
    messageEl.className = `message ${type}`;
    messageEl.style.display = 'block';
    
    setTimeout(() => {
      messageEl.style.display = 'none';
    }, 3000);
  }
}

// 初始化弹窗管理器
document.addEventListener('DOMContentLoaded', () => {
  new PopupManager();
});
```

## 3. 数据库设计与优化

### 3.1 数据库模式优化
```typescript
// 优化后的数据库模式
import { sqliteTable, text, integer, index } from 'drizzle-orm/sqlite-core';

export const users = sqliteTable('users', {
  id: text('id').primaryKey(),
  email: text('email').notNull().unique(),
  name: text('name'),
  avatar: text('avatar'),
  passwordHash: text('password_hash'),
  subscriptionType: text('subscription_type').default('free'),
  subscriptionExpiry: integer('subscription_expiry', { mode: 'timestamp' }),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
}, (table) => ({
  emailIdx: index('users_email_idx').on(table.email),
  subscriptionIdx: index('users_subscription_idx').on(table.subscriptionType),
}));

export const articles = sqliteTable('articles', {
  id: text('id').primaryKey(),
  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  title: text('title').notNull(),
  content: text('content').notNull(),
  status: text('status').notNull().default('draft'),
  wordCount: integer('word_count').default(0),
  readingTime: integer('reading_time').default(0),
  tags: text('tags'), // JSON字符串
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
}, (table) => ({
  userIdIdx: index('articles_user_id_idx').on(table.userId),
  statusIdx: index('articles_status_idx').on(table.status),
  createdAtIdx: index('articles_created_at_idx').on(table.createdAt),
}));

export const publishRecords = sqliteTable('publish_records', {
  id: text('id').primaryKey(),
  articleId: text('article_id').notNull().references(() => articles.id, { onDelete: 'cascade' }),
  platform: text('platform').notNull(),
  status: text('status').notNull().default('pending'),
  publishUrl: text('publish_url'),
  publishedAt: integer('published_at', { mode: 'timestamp' }),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
}, (table) => ({
  articleIdIdx: index('publish_records_article_id_idx').on(table.articleId),
  platformIdx: index('publish_records_platform_idx').on(table.platform),
}));

export const publishPresets = sqliteTable('publish_presets', {
  id: text('id').primaryKey(),
  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  name: text('name').notNull(),
  config: text('config').notNull(), // JSON配置
  isDefault: integer('is_default', { mode: 'boolean' }).default(false),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
}, (table) => ({
  userIdIdx: index('publish_presets_user_id_idx').on(table.userId),
  defaultIdx: index('publish_presets_default_idx').on(table.isDefault),
}));

export const aiUsage = sqliteTable('ai_usage', {
  id: text('id').primaryKey(),
  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  featureType: text('feature_type').notNull(),
  usageCount: integer('usage_count').default(1),
  month: text('month').notNull(), // YYYY-MM格式
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
}, (table) => ({
  userMonthIdx: index('ai_usage_user_month_idx').on(table.userId, table.month),
  featureIdx: index('ai_usage_feature_idx').on(table.featureType),
}));
```

### 3.2 查询优化
```typescript
// 优化的数据访问层
class ArticleRepository {
  constructor(private db: Database) {}
  
  async getUserArticles(userId: string, limit = 20, offset = 0): Promise<Article[]> {
    return this.db.query.articles.findMany({
      where: eq(articles.userId, userId),
      orderBy: [desc(articles.updatedAt)],
      limit,
      offset,
    });
  }
  
  async getArticleWithPublishRecords(articleId: string): Promise<ArticleWithRecords> {
    const article = await this.db.query.articles.findFirst({
      where: eq(articles.id, articleId),
      with: {
        publishRecords: true,
      },
    });
    
    if (!article) {
      throw new Error('文章不存在');
    }
    
    return article;
  }
  
  async searchArticles(userId: string, query: string): Promise<Article[]> {
    return this.db.query.articles.findMany({
      where: and(
        eq(articles.userId, userId),
        or(
          like(articles.title, `%${query}%`),
          like(articles.content, `%${query}%`)
        )
      ),
      orderBy: [desc(articles.updatedAt)],
      limit: 50,
    });
  }
  
  async getArticleStats(userId: string): Promise<ArticleStats> {
    const stats = await this.db
      .select({
        total: count(),
        published: count(case(eq(articles.status, 'published'), 1)),
        totalWords: sum(articles.wordCount),
      })
      .from(articles)
      .where(eq(articles.userId, userId));
    
    return stats[0];
  }
}
```

## 4. 性能优化策略

### 4.1 前端性能优化
```typescript
// 虚拟滚动实现
import { useState, useEffect, useMemo } from 'react';

interface VirtualListProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
}

function VirtualList<T>({ items, itemHeight, containerHeight, renderItem }: VirtualListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleItems = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + 1,
      items.length
    );
    
    return items.slice(startIndex, endIndex).map((item, index) => ({
      item,
      index: startIndex + index,
    }));
  }, [items, scrollTop, itemHeight, containerHeight]);
  
  return (
    <div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map(({ item, index }) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              top: index * itemHeight,
              height: itemHeight,
              width: '100%',
            }}
          >
            {renderItem(item, index)}
          </div>
        ))}
      </div>
    </div>
  );
}

// 防抖Hook
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// 自动保存Hook
function useAutoSave(content: string, onSave: (content: string) => void) {
  const debouncedContent = useDebounce(content, 2000);
  
  useEffect(() => {
    if (debouncedContent) {
      onSave(debouncedContent);
    }
  }, [debouncedContent, onSave]);
}
```

### 4.2 缓存策略
```typescript
// 多层缓存管理
class CacheManager {
  private memoryCache = new Map<string, CacheItem>();
  private maxSize = 100;
  
  set(key: string, value: any, ttl = 300000): void { // 默认5分钟
    // 清理过期缓存
    this.cleanup();
    
    // 如果缓存已满，删除最旧的项
    if (this.memoryCache.size >= this.maxSize) {
      const firstKey = this.memoryCache.keys().next().value;
      this.memoryCache.delete(firstKey);
    }
    
    this.memoryCache.set(key, {
      value,
      expiry: Date.now() + ttl,
    });
  }
  
  get(key: string): any | null {
    const item = this.memoryCache.get(key);
    
    if (!item) {
      return null;
    }
    
    if (Date.now() > item.expiry) {
      this.memoryCache.delete(key);
      return null;
    }
    
    return item.value;
  }
  
  private cleanup(): void {
    const now = Date.now();
    for (const [key, item] of this.memoryCache.entries()) {
      if (now > item.expiry) {
        this.memoryCache.delete(key);
      }
    }
  }
}

// API响应缓存
const cache = new CacheManager();

async function cachedFetch(url: string, options?: RequestInit): Promise<any> {
  const cacheKey = `${url}_${JSON.stringify(options)}`;
  
  // 尝试从缓存获取
  const cached = cache.get(cacheKey);
  if (cached) {
    return cached;
  }
  
  // 发起请求
  const response = await fetch(url, options);
  const data = await response.json();
  
  // 缓存结果
  cache.set(cacheKey, data);
  
  return data;
}
```

## 5. 安全实现

### 5.1 认证与授权
```typescript
// JWT认证中间件
import { NextRequest, NextResponse } from 'next/server';
import { verify } from 'jsonwebtoken';

export function withAuth(handler: Function) {
  return async (req: NextRequest) => {
    try {
      const token = req.headers.get('authorization')?.replace('Bearer ', '');
      
      if (!token) {
        return NextResponse.json({ error: 'No token provided' }, { status: 401 });
      }
      
      const payload = verify(token, process.env.JWT_SECRET!) as any;
      
      // 将用户信息添加到请求中
      (req as any).user = { id: payload.userId, email: payload.email };
      
      return handler(req);
    } catch (error) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 });
    }
  };
}

// 权限检查
async function checkArticlePermission(userId: string, articleId: string): Promise<boolean> {
  const article = await db.query.articles.findFirst({
    where: eq(articles.id, articleId),
    columns: { userId: true },
  });
  
  return article?.userId === userId;
}
```

### 5.2 输入验证
```typescript
// 输入验证Schema
import { z } from 'zod';

export const createArticleSchema = z.object({
  title: z.string().min(1, '标题不能为空').max(100, '标题过长'),
  content: z.string().min(1, '内容不能为空').max(100000, '内容过长'),
  tags: z.array(z.string()).max(10, '标签过多').optional(),
});

export const updatePresetSchema = z.object({
  name: z.string().min(1, '预设名称不能为空').max(50, '预设名称过长'),
  config: z.object({
    author: z.string().max(50).optional(),
    original: z.boolean().optional(),
    reward: z.boolean().optional(),
    style: z.enum(['default', 'tech', 'minimal']).optional(),
  }),
});

// 内容安全过滤
import DOMPurify from 'isomorphic-dompurify';

export function sanitizeHTML(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'blockquote', 'code', 'pre', 'img', 'a'],
    ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class'],
  });
}
```

## 6. 测试策略

### 6.1 单元测试
```typescript
// 格式转换器测试
import { describe, it, expect } from 'vitest';
import { WechatConverter } from '../lib/converters/wechat';

describe('WechatConverter', () => {
  const converter = new WechatConverter();
  
  it('should convert markdown to wechat format', () => {
    const markdown = '# 标题\n\n这是一段文字。';
    const result = converter.convert(markdown);
    
    expect(result).toContain('<h1>标题</h1>');
    expect(result).toContain('<p>这是一段文字。</p>');
    expect(result).toContain('wechat-content');
  });
  
  it('should handle code blocks correctly', () => {
    const markdown = '```javascript\nconsole.log("hello");\n```';
    const result = converter.convert(markdown);
    
    expect(result).toContain('<pre>');
    expect(result).toContain('<code>');
    expect(result).toContain('console.log');
  });
});

// AI服务测试
describe('AIService', () => {
  const aiService = new TongYiAIProvider('test-key');
  
  it('should optimize title', async () => {
    const content = '这是一篇关于JavaScript的文章';
    const titles = await aiService.optimizeTitle(content);
    
    expect(titles).toHaveLength(3);
    expect(titles[0]).toBeTruthy();
  });
});
```

### 6.2 集成测试
```typescript
// API测试
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { createTestDatabase, cleanupTestDatabase } from './test-utils';

describe('Articles API', () => {
  let db: Database;
  let userId: string;
  
  beforeAll(async () => {
    db = await createTestDatabase();
    userId = await createTestUser(db);
  });
  
  afterAll(async () => {
    await cleanupTestDatabase(db);
  });
  
  it('should create article', async () => {
    const response = await fetch('/api/articles', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getTestToken(userId)}`,
      },
      body: JSON.stringify({
        title: '测试文章',
        content: '这是测试内容',
      }),
    });
    
    expect(response.status).toBe(201);
    
    const data = await response.json();
    expect(data.article.title).toBe('测试文章');
  });
});
```

## 7. 部署与运维

### 7.1 环境配置
```bash
# .env.local
# 数据库配置
DATABASE_URL="file:./dev.db"
TURSO_DATABASE_URL="libsql://your-db.turso.io"
TURSO_AUTH_TOKEN="your-auth-token"

# 认证配置
NEXTAUTH_SECRET="your-super-secret-key"
NEXTAUTH_URL="http://localhost:3000"

# AI服务配置
TONGYI_API_KEY="your-tongyi-api-key"

# 图床配置
SMMS_API_KEY="your-smms-api-key"

# 邮件配置（可选）
EMAIL_SERVER="smtp://username:password@smtp.example.com:587"
EMAIL_FROM="noreply@example.com"
```

### 7.2 部署脚本
```bash
#!/bin/bash
# deploy.sh

echo "开始部署文流应用..."

# 1. 安装依赖
echo "安装依赖..."
npm ci

# 2. 构建应用
echo "构建应用..."
npm run build

# 3. 数据库迁移
echo "执行数据库迁移..."
npm run db:push

# 4. 启动应用
echo "启动应用..."
npm start

echo "部署完成！"
```

### 7.3 监控配置
```typescript
// 应用监控
export function setupMonitoring() {
  // 错误监控
  process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
    // 发送到监控服务
  });
  
  process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    // 发送到监控服务
  });
  
  // 性能监控
  setInterval(() => {
    const memUsage = process.memoryUsage();
    console.log('Memory Usage:', {
      rss: Math.round(memUsage.rss / 1024 / 1024) + 'MB',
      heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024) + 'MB',
      heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024) + 'MB',
    });
  }, 60000); // 每分钟记录一次
}
```

这份技术设计文档涵盖了文流项目的完整技术实现，从前端到后端，从数据库到AI服务，从Chrome插件到部署运维，为开发团队提供了详细的技术指导。